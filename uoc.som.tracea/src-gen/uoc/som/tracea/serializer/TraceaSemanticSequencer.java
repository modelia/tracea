/*
 * generated by Xtext 2.21.0
 */
package uoc.som.tracea.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tracea.Tracea;
import tracea.TraceaPackage;
import tracea.core.AIEvidence;
import tracea.core.AnnotationEvidence;
import tracea.core.CorePackage;
import tracea.core.Evidence;
import tracea.core.LeafTraceLink;
import tracea.core.NodeTraceLink;
import tracea.core.Referee;
import tracea.core.RuleEvidence;
import tracea.core.Trace;
import tracea.granularity.Classe;
import tracea.granularity.Document;
import tracea.granularity.GranularityPackage;
import tracea.granularity.Model;
import tracea.granularity.ModelArtefact;
import tracea.granularity.ModelFragment;
import tracea.granularity.NamedElement;
import tracea.granularity.PartOfSpeech;
import tracea.granularity.Section;
import tracea.granularity.StructuralFeature;
import tracea.granularity.TextArtefact;
import tracea.granularity.TextFragment;
import tracea.relationtyping.Doc2Section;
import tracea.relationtyping.DomainType;
import tracea.relationtyping.EngineeringType;
import tracea.relationtyping.NameEntity2Package;
import tracea.relationtyping.NamedEntity2Class;
import tracea.relationtyping.NamedEntitySynonym;
import tracea.relationtyping.Package2Model;
import tracea.relationtyping.PoS2NamedEntity;
import tracea.relationtyping.PoSSynonym;
import tracea.relationtyping.RelationtypingPackage;
import tracea.relationtyping.Section2PoS;
import tracea.relationtyping.Transclusion;
import uoc.som.tracea.services.TraceaGrammarAccess;

@SuppressWarnings("all")
public class TraceaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TraceaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CorePackage.AI_EVIDENCE:
				sequence_AIEvidence(context, (AIEvidence) semanticObject); 
				return; 
			case CorePackage.ANNOTATION_EVIDENCE:
				sequence_AnnotationEvidence(context, (AnnotationEvidence) semanticObject); 
				return; 
			case CorePackage.EVIDENCE:
				sequence_Evidence_Impl(context, (Evidence) semanticObject); 
				return; 
			case CorePackage.LEAF_TRACE_LINK:
				sequence_LeafTraceLink(context, (LeafTraceLink) semanticObject); 
				return; 
			case CorePackage.NODE_TRACE_LINK:
				sequence_NodeTraceLink(context, (NodeTraceLink) semanticObject); 
				return; 
			case CorePackage.REFEREE:
				sequence_Referee(context, (Referee) semanticObject); 
				return; 
			case CorePackage.RULE_EVIDENCE:
				sequence_RuleEvidence(context, (RuleEvidence) semanticObject); 
				return; 
			case CorePackage.TRACE:
				sequence_Trace(context, (Trace) semanticObject); 
				return; 
			}
		else if (epackage == GranularityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GranularityPackage.CLASSE:
				sequence_Classe(context, (Classe) semanticObject); 
				return; 
			case GranularityPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case GranularityPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GranularityPackage.MODEL_ARTEFACT:
				sequence_ModelArtefact_Impl(context, (ModelArtefact) semanticObject); 
				return; 
			case GranularityPackage.MODEL_FRAGMENT:
				sequence_ModelFragment_Impl(context, (ModelFragment) semanticObject); 
				return; 
			case GranularityPackage.NAMED_ELEMENT:
				sequence_NamedElement(context, (NamedElement) semanticObject); 
				return; 
			case GranularityPackage.PACKAGE:
				sequence_Package(context, (tracea.granularity.Package) semanticObject); 
				return; 
			case GranularityPackage.PART_OF_SPEECH:
				sequence_PartOfSpeech(context, (PartOfSpeech) semanticObject); 
				return; 
			case GranularityPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case GranularityPackage.STRUCTURAL_FEATURE:
				sequence_StructuralFeature(context, (StructuralFeature) semanticObject); 
				return; 
			case GranularityPackage.TEXT_ARTEFACT:
				sequence_TextArtefact_Impl(context, (TextArtefact) semanticObject); 
				return; 
			case GranularityPackage.TEXT_FRAGMENT:
				sequence_TextFragment_Impl(context, (TextFragment) semanticObject); 
				return; 
			}
		else if (epackage == RelationtypingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RelationtypingPackage.DOC2_SECTION:
				sequence_Doc2Section(context, (Doc2Section) semanticObject); 
				return; 
			case RelationtypingPackage.DOMAIN_TYPE:
				sequence_DomainType_Impl(context, (DomainType) semanticObject); 
				return; 
			case RelationtypingPackage.ENGINEERING_TYPE:
				sequence_EngineeringType_Impl(context, (EngineeringType) semanticObject); 
				return; 
			case RelationtypingPackage.NAME_ENTITY2_PACKAGE:
				sequence_NameEntity2Package(context, (NameEntity2Package) semanticObject); 
				return; 
			case RelationtypingPackage.NAMED_ENTITY2_CLASS:
				sequence_NamedEntity2Class(context, (NamedEntity2Class) semanticObject); 
				return; 
			case RelationtypingPackage.NAMED_ENTITY_SYNONYM:
				sequence_NamedEntitySynonym(context, (NamedEntitySynonym) semanticObject); 
				return; 
			case RelationtypingPackage.PACKAGE2_MODEL:
				sequence_Package2Model(context, (Package2Model) semanticObject); 
				return; 
			case RelationtypingPackage.PO_S2_NAMED_ENTITY:
				sequence_PoS2NamedEntity(context, (PoS2NamedEntity) semanticObject); 
				return; 
			case RelationtypingPackage.PO_SSYNONYM:
				sequence_PoSSynonym(context, (PoSSynonym) semanticObject); 
				return; 
			case RelationtypingPackage.SECTION2_PO_S:
				sequence_Section2PoS(context, (Section2PoS) semanticObject); 
				return; 
			case RelationtypingPackage.TRANSCLUSION:
				sequence_Transclusion(context, (Transclusion) semanticObject); 
				return; 
			}
		else if (epackage == TraceaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TraceaPackage.TRACEA:
				sequence_Tracea(context, (Tracea) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TrustableElement returns AIEvidence
	 *     Evidence returns AIEvidence
	 *     AIEvidence returns AIEvidence
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         algorithmUsed=EString? 
	 *         (parameters+=EString parameters+=EString*)? 
	 *         executionDate=EString? 
	 *         (precision=EDouble recall=EDouble)? 
	 *         (impactedElements+=[TrustableElement|EString] impactedElements+=[TrustableElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_AIEvidence(ISerializationContext context, AIEvidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns AnnotationEvidence
	 *     Evidence returns AnnotationEvidence
	 *     AnnotationEvidence returns AnnotationEvidence
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         content=EString? 
	 *         (impactedElements+=[TrustableElement|EString] impactedElements+=[TrustableElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_AnnotationEvidence(ISerializationContext context, AnnotationEvidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns Classe
	 *     ModelFragment returns Classe
	 *     Classe returns Classe
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (namedelementsDefined+=[NamedElement|EString] namedelementsDefined+=[NamedElement|EString]*)? 
	 *         (namedelementsUsed+=[NamedElement|EString] namedelementsUsed+=[NamedElement|EString]*)? 
	 *         (structuralfeatures+=[StructuralFeature|EString] structuralfeatures+=[StructuralFeature|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Classe(ISerializationContext context, Classe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns Doc2Section
	 *     Doc2Section returns Doc2Section
	 *
	 * Constraint:
	 *     {Doc2Section}
	 */
	protected void sequence_Doc2Section(ISerializationContext context, Doc2Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artefact returns Document
	 *     TextArtefact returns Document
	 *     Document returns Document
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         title=EString? 
	 *         (fragments+=[ArtefactFragment|EString] fragments+=[ArtefactFragment|EString]*)? 
	 *         (sections+=[Section|EString] sections+=[Section|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns DomainType
	 *     DomainType_Impl returns DomainType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_DomainType_Impl(ISerializationContext context, DomainType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RelationtypingPackage.Literals.RELATIONSHIP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RelationtypingPackage.Literals.RELATIONSHIP_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns EngineeringType
	 *     EngineeringType_Impl returns EngineeringType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_EngineeringType_Impl(ISerializationContext context, EngineeringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RelationtypingPackage.Literals.RELATIONSHIP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RelationtypingPackage.Literals.RELATIONSHIP_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEngineeringType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns Evidence
	 *     Evidence returns Evidence
	 *     Evidence_Impl returns Evidence
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (impactedElements+=[TrustableElement|EString] impactedElements+=[TrustableElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Evidence_Impl(ISerializationContext context, Evidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns LeafTraceLink
	 *     TraceLink returns LeafTraceLink
	 *     LeafTraceLink returns LeafTraceLink
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         source=[ArtefactFragment|EString]? 
	 *         target=[ArtefactFragment|EString]? 
	 *         relationshiptype=[RelationshipType|EString]? 
	 *         (evidences+=[Evidence|EString] evidences+=[Evidence|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_LeafTraceLink(ISerializationContext context, LeafTraceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artefact returns ModelArtefact
	 *     ModelArtefact returns ModelArtefact
	 *     ModelArtefact_Impl returns ModelArtefact
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (fragments+=[ArtefactFragment|EString] fragments+=[ArtefactFragment|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_ModelArtefact_Impl(ISerializationContext context, ModelArtefact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns ModelFragment
	 *     ModelFragment returns ModelFragment
	 *     ModelFragment_Impl returns ModelFragment
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (namedelementsDefined+=[NamedElement|EString] namedelementsDefined+=[NamedElement|EString]*)? 
	 *         (namedelementsUsed+=[NamedElement|EString] namedelementsUsed+=[NamedElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_ModelFragment_Impl(ISerializationContext context, ModelFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artefact returns Model
	 *     ModelArtefact returns Model
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (fragments+=[ArtefactFragment|EString] fragments+=[ArtefactFragment|EString]*)? 
	 *         (packages+=[Package|EString] packages+=[Package|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns NameEntity2Package
	 *     NameEntity2Package returns NameEntity2Package
	 *
	 * Constraint:
	 *     {NameEntity2Package}
	 */
	protected void sequence_NameEntity2Package(ISerializationContext context, NameEntity2Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns NamedElement
	 *     ModelFragment returns NamedElement
	 *     NamedElement returns NamedElement
	 *
	 * Constraint:
	 *     (name=EString (referees+=[Referee|EString] referees+=[Referee|EString]*)? timestamp=EString?)
	 */
	protected void sequence_NamedElement(ISerializationContext context, NamedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns NamedEntity2Class
	 *     NamedEntity2Class returns NamedEntity2Class
	 *
	 * Constraint:
	 *     {NamedEntity2Class}
	 */
	protected void sequence_NamedEntity2Class(ISerializationContext context, NamedEntity2Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns NamedEntitySynonym
	 *     NamedEntitySynonym returns NamedEntitySynonym
	 *
	 * Constraint:
	 *     {NamedEntitySynonym}
	 */
	protected void sequence_NamedEntitySynonym(ISerializationContext context, NamedEntitySynonym semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns NodeTraceLink
	 *     TraceLink returns NodeTraceLink
	 *     NodeTraceLink returns NodeTraceLink
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         source=[ArtefactFragment|EString]? 
	 *         target=[ArtefactFragment|EString]? 
	 *         (successors+=[TraceLink|EString] successors+=[TraceLink|EString]*)? 
	 *         relationshiptype=[RelationshipType|EString]? 
	 *         (evidences+=[Evidence|EString] evidences+=[Evidence|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_NodeTraceLink(ISerializationContext context, NodeTraceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns Package2Model
	 *     Package2Model returns Package2Model
	 *
	 * Constraint:
	 *     {Package2Model}
	 */
	protected void sequence_Package2Model(ISerializationContext context, Package2Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns Package
	 *     ModelFragment returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (namedelementsDefined+=[NamedElement|EString] namedelementsDefined+=[NamedElement|EString]*)? 
	 *         (namedelementsUsed+=[NamedElement|EString] namedelementsUsed+=[NamedElement|EString]*)? 
	 *         (classes+=[Classe|EString] classes+=[Classe|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Package(ISerializationContext context, tracea.granularity.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns PartOfSpeech
	 *     TextFragment returns PartOfSpeech
	 *     PartOfSpeech returns PartOfSpeech
	 *
	 * Constraint:
	 *     (name=EString position=EString? (referees+=[Referee|EString] referees+=[Referee|EString]*)? timestamp=EString?)
	 */
	protected void sequence_PartOfSpeech(ISerializationContext context, PartOfSpeech semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns PoS2NamedEntity
	 *     PoS2NamedEntity returns PoS2NamedEntity
	 *
	 * Constraint:
	 *     {PoS2NamedEntity}
	 */
	protected void sequence_PoS2NamedEntity(ISerializationContext context, PoS2NamedEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns PoSSynonym
	 *     PoSSynonym returns PoSSynonym
	 *
	 * Constraint:
	 *     {PoSSynonym}
	 */
	protected void sequence_PoSSynonym(ISerializationContext context, PoSSynonym semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referee returns Referee
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Referee(ISerializationContext context, Referee semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.REFEREE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.REFEREE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefereeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns RuleEvidence
	 *     Evidence returns RuleEvidence
	 *     RuleEvidence returns RuleEvidence
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         rule=EString? 
	 *         executionDate=EString? 
	 *         (impactedElements+=[TrustableElement|EString] impactedElements+=[TrustableElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_RuleEvidence(ISerializationContext context, RuleEvidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns Section2PoS
	 *     Section2PoS returns Section2PoS
	 *
	 * Constraint:
	 *     {Section2PoS}
	 */
	protected void sequence_Section2PoS(ISerializationContext context, Section2PoS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns Section
	 *     TextFragment returns Section
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         number=EInt? 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (partofspeechsDefined+=[PartOfSpeech|EString] partofspeechsDefined+=[PartOfSpeech|EString]*)? 
	 *         (partofspeechsUsed+=[PartOfSpeech|EString] partofspeechsUsed+=[PartOfSpeech|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns StructuralFeature
	 *     ModelFragment returns StructuralFeature
	 *     StructuralFeature returns StructuralFeature
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (namedelementsDefined+=[NamedElement|EString] namedelementsDefined+=[NamedElement|EString]*)? 
	 *         (namedelementsUsed+=[NamedElement|EString] namedelementsUsed+=[NamedElement|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_StructuralFeature(ISerializationContext context, StructuralFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artefact returns TextArtefact
	 *     TextArtefact returns TextArtefact
	 *     TextArtefact_Impl returns TextArtefact
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (fragments+=[ArtefactFragment|EString] fragments+=[ArtefactFragment|EString]*)? 
	 *         timestamp=EString? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)?
	 *     )
	 */
	protected void sequence_TextArtefact_Impl(ISerializationContext context, TextArtefact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArtefactFragment returns TextFragment
	 *     TextFragment returns TextFragment
	 *     TextFragment_Impl returns TextFragment
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subFragments+=[ArtefactFragment|EString] subFragments+=[ArtefactFragment|EString]*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_TextFragment_Impl(ISerializationContext context, TextFragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrustableElement returns Trace
	 *     Trace returns Trace
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         relationshiptype=[RelationshipType|EString]? 
	 *         (evidences+=[Evidence|EString] evidences+=[Evidence|EString]*)? 
	 *         (starts+=[TraceLink|EString] | starts+=[TraceLink|EString]+)? 
	 *         (tracelinks+=TraceLink tracelinks+=TraceLink*)? 
	 *         (referees+=[Referee|EString] referees+=[Referee|EString]*)? 
	 *         timestamp=EString?
	 *     )
	 */
	protected void sequence_Trace(ISerializationContext context, Trace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tracea returns Tracea
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (traces+=Trace traces+=Trace*)? 
	 *         (relationshiptypes+=RelationshipType relationshiptypes+=RelationshipType*)? 
	 *         (artefacts+=Artefact artefacts+=Artefact*)? 
	 *         (fragments+=ArtefactFragment fragments+=ArtefactFragment*)? 
	 *         (evidences+=Evidence evidences+=Evidence*)? 
	 *         (referees+=Referee referees+=Referee*)?
	 *     )
	 */
	protected void sequence_Tracea(ISerializationContext context, Tracea semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns Transclusion
	 *     Transclusion returns Transclusion
	 *
	 * Constraint:
	 *     {Transclusion}
	 */
	protected void sequence_Transclusion(ISerializationContext context, Transclusion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
